initSidebarItems({"fn":[["current_num_threads","Returns the number of threads in the current registry. If this code is executing within a Rayon thread-pool, then this will be the number of threads for the thread-pool of the current thread. Otherwise, it will be the number of threads for the global thread-pool."],["initialize","Initializes the global thread pool. This initialization is optional.  If you do not call this function, the thread pool will be automatically initialized with the default configuration. In fact, calling `initialize` is not recommended, except for in two scenarios:"],["join","The `join` function takes two closures and potentially runs them in parallel. It returns a pair of the results from those closures."],["scope","Create a \"fork-join\" scope `s` and invokes the closure with a reference to `s`. This closure can then spawn asynchronous tasks into `s`. Those tasks may run asynchronously with respect to the closure; they may themselves spawn additional tasks into `s`. When the closure returns, it will block until all tasks that have been spawned into `s` complete."],["spawn","Fires off a task into the Rayon threadpool in the \"static\" or \"global\" scope.  Just like a standard thread, this task is not tied to the current stack frame, and hence it cannot hold any references other than those with `'static` lifetime. If you want to spawn a task that references stack data, use [the `scope()` function][scope] to create a scope."],["split","The `split` function takes arbitrary data and a closure that knows how to split it, and turns this into a `ParallelIterator`."]],"mod":[["collections","This module contains the parallel iterator types for standard collections. You will rarely need to interact with it directly unless you have need to name one of the iterator types."],["iter","The `ParallelIterator` module makes it easy to write parallel programs using an iterator-style interface. To get access to all the methods you want, the easiest is to write `use rayon::prelude::*;` at the top of your module, which will import the various traits and methods you need."],["option","This module contains the parallel iterator types for options (`Option<T>`). You will rarely need to interact with it directly unless you have need to name one of the iterator types."],["prelude","The rayon prelude imports the various `ParallelIterator` traits. The intention is that one can include `use rayon::prelude::*` and have easy access to the various traits and methods you will need."],["range","This module contains the parallel iterator types for ranges (`Range<T>`); this is the type for values created by a `a..b` expression. You will rarely need to interact with it directly unless you have need to name one of the iterator types."],["result","This module contains the parallel iterator types for results (`Result<T, E>`). You will rarely need to interact with it directly unless you have need to name one of the iterator types."],["slice","This module contains the parallel iterator types for slices (`[T]`). You will rarely need to interact with it directly unless you have need to name one of those types."],["str","This module contains extension methods for `String` that expose parallel iterators, such as `par_split_whitespace()`. You will rarely need to interact with it directly, since if you add `use rayon::prelude::*` to your file, that will include the helper traits defined in this module."],["vec","This module contains the parallel iterator types for vectors (`Vec<T>`). You will rarely need to interact with it directly unless you have need to name one of those types."]],"struct":[["Configuration","Contains the rayon thread pool configuration."],["Scope","Represents a fork-join scope which can be used to spawn any number of tasks. See [`scope()`] for more information."],["ThreadPool","ThreadPool"]]});