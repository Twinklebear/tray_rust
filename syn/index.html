<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="API documentation for the Rust `syn` crate."><meta name="keywords" content="rust, rustlang, rust-lang, syn"><title>syn - Rust</title><link rel="stylesheet" type="text/css" href="../normalize.css"><link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../dark.css"><link rel="stylesheet" type="text/css" href="../light.css" id="themeStyle"><script src="../storage.js"></script><noscript><link rel="stylesheet" href="../noscript.css"></noscript><link rel="shortcut icon" href="../favicon.ico"><style type="text/css">#crate-search{background-image:url("../down-arrow.svg");}</style></head><body class="rustdoc mod"><!--[if lte IE 8]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="sidebar-menu">&#9776;</div><a href='../syn/index.html'><div class='logo-container'><img src='../rust-logo.png' alt='logo'></div></a><p class='location'>Crate syn</p><div class="sidebar-elems"><a id='all-types' href='all.html'><p>See all syn's items</p></a><div class="block items"><ul><li><a href="#modules">Modules</a></li><li><a href="#structs">Structs</a></li><li><a href="#enums">Enums</a></li><li><a href="#functions">Functions</a></li></ul></div><p class='location'></p><script>window.sidebarCurrent = {name: 'syn', ty: 'mod', relpath: '../'};</script></div></nav><div class="theme-picker"><button id="theme-picker" aria-label="Pick another theme!"><img src="../brush.svg" width="18" alt="Pick another theme!"></button><div id="theme-choices"></div></div><script src="../theme.js"></script><nav class="sub"><form class="search-form js-only"><div class="search-container"><div><select id="crate-search"><option value="All crates">All crates</option></select><input class="search-input" name="search" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"></div><a id="settings-menu" href="../settings.html"><img src="../wheel.svg" width="18" alt="Change settings"></a></div></form></nav><section id="main" class="content"><h1 class='fqn'><span class='out-of-band'><span id='render-detail'><a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class='inner'>&#x2212;</span>]</a></span><a class='srclink' href='../src/syn/lib.rs.html#1-211' title='goto source code'>[src]</a></span><span class='in-band'>Crate <a class="mod" href=''>syn</a></span></h1><h2 id='modules' class='section-header'><a href="#modules">Modules</a></h2>
<table><tr class='module-item'><td><a class="mod" href="parse/index.html" title='syn::parse mod'>parse</a></td><td class='docblock-short'><p>This module contains a set of exported nom parsers which can be used to
parse custom grammars when used alongside the <code>synom</code> crate.</p>
</td></tr><tr class='module-item'><td><a class="mod" href="visit/index.html" title='syn::visit mod'>visit</a></td><td class='docblock-short'><p>AST walker. Each overridden visit method has full control over what
happens with its node, it can do its own traversal of the node's children,
call <code>visit::walk_*</code> to apply the default traversal algorithm, or prevent
deeper traversal by doing nothing.</p>
</td></tr></table><h2 id='structs' class='section-header'><a href="#structs">Structs</a></h2>
<table><tr class='module-item'><td><a class="struct" href="struct.AngleBracketedParameterData.html" title='syn::AngleBracketedParameterData struct'>AngleBracketedParameterData</a></td><td class='docblock-short'><p>A path like <code>Foo&lt;'a, T&gt;</code></p>
</td></tr><tr class='module-item'><td><a class="struct" href="struct.Attribute.html" title='syn::Attribute struct'>Attribute</a></td><td class='docblock-short'><p>Doc-comments are promoted to attributes that have <code>is_sugared_doc</code> = true</p>
</td></tr><tr class='module-item'><td><a class="struct" href="struct.BareFnArg.html" title='syn::BareFnArg struct'>BareFnArg</a></td><td class='docblock-short'><p>An argument in a function type.</p>
</td></tr><tr class='module-item'><td><a class="struct" href="struct.BareFnTy.html" title='syn::BareFnTy struct'>BareFnTy</a></td><td class='docblock-short'></td></tr><tr class='module-item'><td><a class="struct" href="struct.ByteStrLit.html" title='syn::ByteStrLit struct'>ByteStrLit</a></td><td class='docblock-short'></td></tr><tr class='module-item'><td><a class="struct" href="struct.Delimited.html" title='syn::Delimited struct'>Delimited</a></td><td class='docblock-short'></td></tr><tr class='module-item'><td><a class="struct" href="struct.DeriveInput.html" title='syn::DeriveInput struct'>DeriveInput</a></td><td class='docblock-short'><p>Struct or enum sent to a <code>proc_macro_derive</code> macro.</p>
</td></tr><tr class='module-item'><td><a class="struct" href="struct.Field.html" title='syn::Field struct'>Field</a></td><td class='docblock-short'><p>A field of a struct or enum variant.</p>
</td></tr><tr class='module-item'><td><a class="struct" href="struct.FloatLit.html" title='syn::FloatLit struct'>FloatLit</a></td><td class='docblock-short'></td></tr><tr class='module-item'><td><a class="struct" href="struct.Generics.html" title='syn::Generics struct'>Generics</a></td><td class='docblock-short'><p>Represents lifetimes and type parameters attached to a declaration
of a function, enum, trait, etc.</p>
</td></tr><tr class='module-item'><td><a class="struct" href="struct.Ident.html" title='syn::Ident struct'>Ident</a></td><td class='docblock-short'></td></tr><tr class='module-item'><td><a class="struct" href="struct.ImplGenerics.html" title='syn::ImplGenerics struct'>ImplGenerics</a></td><td class='docblock-short'><p>Returned by <code>Generics::split_for_impl</code>.</p>
</td></tr><tr class='module-item'><td><a class="struct" href="struct.IntLit.html" title='syn::IntLit struct'>IntLit</a></td><td class='docblock-short'></td></tr><tr class='module-item'><td><a class="struct" href="struct.Lifetime.html" title='syn::Lifetime struct'>Lifetime</a></td><td class='docblock-short'></td></tr><tr class='module-item'><td><a class="struct" href="struct.LifetimeDef.html" title='syn::LifetimeDef struct'>LifetimeDef</a></td><td class='docblock-short'><p>A lifetime definition, e.g. <code>'a: 'b+'c+'d</code></p>
</td></tr><tr class='module-item'><td><a class="struct" href="struct.Mac.html" title='syn::Mac struct'>Mac</a></td><td class='docblock-short'><p>Represents a macro invocation. The Path indicates which macro
is being invoked, and the vector of token-trees contains the source
of the macro invocation.</p>
</td></tr><tr class='module-item'><td><a class="struct" href="struct.MutTy.html" title='syn::MutTy struct'>MutTy</a></td><td class='docblock-short'></td></tr><tr class='module-item'><td><a class="struct" href="struct.ParenthesizedParameterData.html" title='syn::ParenthesizedParameterData struct'>ParenthesizedParameterData</a></td><td class='docblock-short'><p>A path like <code>Foo(A,B) -&gt; C</code></p>
</td></tr><tr class='module-item'><td><a class="struct" href="struct.Path.html" title='syn::Path struct'>Path</a></td><td class='docblock-short'><p>A &quot;Path&quot; is essentially Rust's notion of a name.</p>
</td></tr><tr class='module-item'><td><a class="struct" href="struct.PathSegment.html" title='syn::PathSegment struct'>PathSegment</a></td><td class='docblock-short'><p>A segment of a path: an identifier, an optional lifetime, and a set of types.</p>
</td></tr><tr class='module-item'><td><a class="struct" href="struct.PolyTraitRef.html" title='syn::PolyTraitRef struct'>PolyTraitRef</a></td><td class='docblock-short'></td></tr><tr class='module-item'><td><a class="struct" href="struct.QSelf.html" title='syn::QSelf struct'>QSelf</a></td><td class='docblock-short'><p>The explicit Self type in a &quot;qualified path&quot;. The actual
path, including the trait and the associated item, is stored
separately. <code>position</code> represents the index of the associated
item qualified with this Self type.</p>
</td></tr><tr class='module-item'><td><a class="struct" href="struct.StrLit.html" title='syn::StrLit struct'>StrLit</a></td><td class='docblock-short'></td></tr><tr class='module-item'><td><a class="struct" href="struct.Turbofish.html" title='syn::Turbofish struct'>Turbofish</a></td><td class='docblock-short'><p>Returned by <code>TyGenerics::as_turbofish</code>.</p>
</td></tr><tr class='module-item'><td><a class="struct" href="struct.TyGenerics.html" title='syn::TyGenerics struct'>TyGenerics</a></td><td class='docblock-short'><p>Returned by <code>Generics::split_for_impl</code>.</p>
</td></tr><tr class='module-item'><td><a class="struct" href="struct.TyParam.html" title='syn::TyParam struct'>TyParam</a></td><td class='docblock-short'><p>A generic type parameter, e.g. <code>T: Into&lt;String&gt;</code>.</p>
</td></tr><tr class='module-item'><td><a class="struct" href="struct.TypeBinding.html" title='syn::TypeBinding struct'>TypeBinding</a></td><td class='docblock-short'><p>Bind a type to an associated type: <code>A=Foo</code>.</p>
</td></tr><tr class='module-item'><td><a class="struct" href="struct.Variant.html" title='syn::Variant struct'>Variant</a></td><td class='docblock-short'><p>An enum variant.</p>
</td></tr><tr class='module-item'><td><a class="struct" href="struct.WhereBoundPredicate.html" title='syn::WhereBoundPredicate struct'>WhereBoundPredicate</a></td><td class='docblock-short'><p>A type bound.</p>
</td></tr><tr class='module-item'><td><a class="struct" href="struct.WhereClause.html" title='syn::WhereClause struct'>WhereClause</a></td><td class='docblock-short'><p>A <code>where</code> clause in a definition</p>
</td></tr><tr class='module-item'><td><a class="struct" href="struct.WhereEqPredicate.html" title='syn::WhereEqPredicate struct'>WhereEqPredicate</a></td><td class='docblock-short'><p>An equality predicate (unsupported).</p>
</td></tr><tr class='module-item'><td><a class="struct" href="struct.WhereRegionPredicate.html" title='syn::WhereRegionPredicate struct'>WhereRegionPredicate</a></td><td class='docblock-short'><p>A lifetime predicate.</p>
</td></tr></table><h2 id='enums' class='section-header'><a href="#enums">Enums</a></h2>
<table><tr class='module-item'><td><a class="enum" href="enum.Abi.html" title='syn::Abi enum'>Abi</a></td><td class='docblock-short'></td></tr><tr class='module-item'><td><a class="enum" href="enum.AttrStyle.html" title='syn::AttrStyle enum'>AttrStyle</a></td><td class='docblock-short'><p>Distinguishes between Attributes that decorate items and Attributes that
are contained as statements within items. These two cases need to be
distinguished for pretty-printing.</p>
</td></tr><tr class='module-item'><td><a class="enum" href="enum.BinOp.html" title='syn::BinOp enum'>BinOp</a></td><td class='docblock-short'></td></tr><tr class='module-item'><td><a class="enum" href="enum.BinOpToken.html" title='syn::BinOpToken enum'>BinOpToken</a></td><td class='docblock-short'></td></tr><tr class='module-item'><td><a class="enum" href="enum.Body.html" title='syn::Body enum'>Body</a></td><td class='docblock-short'><p>Body of a derived struct or enum.</p>
</td></tr><tr class='module-item'><td><a class="enum" href="enum.ConstExpr.html" title='syn::ConstExpr enum'>ConstExpr</a></td><td class='docblock-short'></td></tr><tr class='module-item'><td><a class="enum" href="enum.DelimToken.html" title='syn::DelimToken enum'>DelimToken</a></td><td class='docblock-short'><p>A delimiter token</p>
</td></tr><tr class='module-item'><td><a class="enum" href="enum.FloatTy.html" title='syn::FloatTy enum'>FloatTy</a></td><td class='docblock-short'></td></tr><tr class='module-item'><td><a class="enum" href="enum.FunctionRetTy.html" title='syn::FunctionRetTy enum'>FunctionRetTy</a></td><td class='docblock-short'></td></tr><tr class='module-item'><td><a class="enum" href="enum.IntTy.html" title='syn::IntTy enum'>IntTy</a></td><td class='docblock-short'></td></tr><tr class='module-item'><td><a class="enum" href="enum.Lit.html" title='syn::Lit enum'>Lit</a></td><td class='docblock-short'><p>Literal kind.</p>
</td></tr><tr class='module-item'><td><a class="enum" href="enum.MetaItem.html" title='syn::MetaItem enum'>MetaItem</a></td><td class='docblock-short'><p>A compile-time attribute item.</p>
</td></tr><tr class='module-item'><td><a class="enum" href="enum.Mutability.html" title='syn::Mutability enum'>Mutability</a></td><td class='docblock-short'></td></tr><tr class='module-item'><td><a class="enum" href="enum.NestedMetaItem.html" title='syn::NestedMetaItem enum'>NestedMetaItem</a></td><td class='docblock-short'><p>Possible values inside of compile-time attribute lists.</p>
</td></tr><tr class='module-item'><td><a class="enum" href="enum.PathParameters.html" title='syn::PathParameters enum'>PathParameters</a></td><td class='docblock-short'><p>Parameters of a path segment.</p>
</td></tr><tr class='module-item'><td><a class="enum" href="enum.StrStyle.html" title='syn::StrStyle enum'>StrStyle</a></td><td class='docblock-short'></td></tr><tr class='module-item'><td><a class="enum" href="enum.Token.html" title='syn::Token enum'>Token</a></td><td class='docblock-short'></td></tr><tr class='module-item'><td><a class="enum" href="enum.TokenTree.html" title='syn::TokenTree enum'>TokenTree</a></td><td class='docblock-short'><p>When the main rust parser encounters a syntax-extension invocation, it
parses the arguments to the invocation as a token-tree. This is a very
loose structure, such that all sorts of different AST-fragments can
be passed to syntax extensions using a uniform type.</p>
</td></tr><tr class='module-item'><td><a class="enum" href="enum.TraitBoundModifier.html" title='syn::TraitBoundModifier enum'>TraitBoundModifier</a></td><td class='docblock-short'><p>A modifier on a bound, currently this is only used for <code>?Sized</code>, where the
modifier is <code>Maybe</code>. Negative bounds should also be handled here.</p>
</td></tr><tr class='module-item'><td><a class="enum" href="enum.Ty.html" title='syn::Ty enum'>Ty</a></td><td class='docblock-short'><p>The different kinds of types recognized by the compiler</p>
</td></tr><tr class='module-item'><td><a class="enum" href="enum.TyParamBound.html" title='syn::TyParamBound enum'>TyParamBound</a></td><td class='docblock-short'><p>The AST represents all type param bounds as types.
<code>typeck::collect::compute_bounds</code> matches these against
the &quot;special&quot; built-in traits (see <code>middle::lang_items</code>) and
detects Copy, Send and Sync.</p>
</td></tr><tr class='module-item'><td><a class="enum" href="enum.UnOp.html" title='syn::UnOp enum'>UnOp</a></td><td class='docblock-short'></td></tr><tr class='module-item'><td><a class="enum" href="enum.Unsafety.html" title='syn::Unsafety enum'>Unsafety</a></td><td class='docblock-short'></td></tr><tr class='module-item'><td><a class="enum" href="enum.VariantData.html" title='syn::VariantData enum'>VariantData</a></td><td class='docblock-short'><p>Data stored within an enum variant or struct.</p>
</td></tr><tr class='module-item'><td><a class="enum" href="enum.Visibility.html" title='syn::Visibility enum'>Visibility</a></td><td class='docblock-short'><p>Visibility level of an item.</p>
</td></tr><tr class='module-item'><td><a class="enum" href="enum.WherePredicate.html" title='syn::WherePredicate enum'>WherePredicate</a></td><td class='docblock-short'><p>A single predicate in a <code>where</code> clause</p>
</td></tr></table><h2 id='functions' class='section-header'><a href="#functions">Functions</a></h2>
<table><tr class='module-item'><td><a class="fn" href="fn.parse_derive_input.html" title='syn::parse_derive_input fn'>parse_derive_input</a></td><td class='docblock-short'></td></tr><tr class='module-item'><td><a class="fn" href="fn.parse_ident.html" title='syn::parse_ident fn'>parse_ident</a></td><td class='docblock-short'></td></tr><tr class='module-item'><td><a class="fn" href="fn.parse_outer_attr.html" title='syn::parse_outer_attr fn'>parse_outer_attr</a></td><td class='docblock-short'></td></tr><tr class='module-item'><td><a class="fn" href="fn.parse_path.html" title='syn::parse_path fn'>parse_path</a></td><td class='docblock-short'></td></tr><tr class='module-item'><td><a class="fn" href="fn.parse_token_trees.html" title='syn::parse_token_trees fn'>parse_token_trees</a></td><td class='docblock-short'></td></tr><tr class='module-item'><td><a class="fn" href="fn.parse_ty_param_bound.html" title='syn::parse_ty_param_bound fn'>parse_ty_param_bound</a></td><td class='docblock-short'></td></tr><tr class='module-item'><td><a class="fn" href="fn.parse_type.html" title='syn::parse_type fn'>parse_type</a></td><td class='docblock-short'></td></tr><tr class='module-item'><td><a class="fn" href="fn.parse_where_clause.html" title='syn::parse_where_clause fn'>parse_where_clause</a></td><td class='docblock-short'></td></tr></table></section><section id="search" class="content hidden"></section><section class="footer"></section><script>window.rootPath = "../";window.currentCrate = "syn";</script><script src="../aliases.js"></script><script src="../main.js"></script><script defer src="../search-index.js"></script></body></html>